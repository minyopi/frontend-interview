<목차>

- [클린코드](#클린-코드)
  - [클린 코드를 위한 공부 정리](#클린-코드를-위한-공부-정리)
    - [적절한 변수, 함수 네이밍](#적절한-변수-함수-네이밍)
    - [선언적 프로그래밍](#선언적-프로그래밍)
    - [추상화](#추상화)
    - [관심사의 분리](#관심사의-분리)
  - [클린 코드에 대한 참고 자료](#클린-코드에-대한-참고-자료)
    - [Clean Code의 주요 원칙 (General)](#clean-code의-주요원칙-general)
    - [Clean Code의 주요 원칙 (Class Design)](#clean-code의-주요-원칙-class-design)
    - [Clean Code](#clean-code)

# 클린 코드

## 클린 코드를 위한 공부 정리

### 적절한 변수, 함수 네이밍

> 💡 구현 방식 대신 무엇인지를 나타내는 변수명 (How vs What)을 선택하여 개발자의 의도를 드러내야 합니다

ex)

- boolean : `is-`, `has-`, `can-`, ...
- function : `get-`, `handle-`, `submit-`, …
- array : `-s` (ex. `users.map(user ⇒ user.id)`), …

[참고자료: Bool 변수 이름 제대로 짓기 위한 최소한의 영어 문법](https://soojin.ro/blog/naming-boolean-variables)

### 선언적 프로그래밍

#### 명령형 프로그래밍 vs 선언적 프로그래밍

명령형과 선언형의 차이는 간단히 표현해보자면 이렇습니다. 명령형은 특정한 동작을 어떻게(How) 달성할 것인지에 집중하고, 선언형은 무엇을(What) 할지에 집중합니다.

**예시로 알아보기**
명령형 프로그래밍의 패러다임으로 저의 출근길을 표현해보자면, 다음과 같습니다.

> 💬 “집에서 나와 오른쪽으로 10m, 다시 왼쪽으로 10m, 언덕을 따라 30m 내려간 뒤 왼편에 보이는 지하철역에서 강남역 방향 지하철을 타고 7정거장을 이동하여 하차한다.” (How)

반면 선언형 프로그래밍에 가깝게 표현한다면 아래와 같습니다.

> 💬 “나는 강남역으로 이동한다” (What)

**React vs Vanilla js**

```js
// #1
const App = () => <div>Hello, Declarative!</div>;

// #2
const hello = document.createElement("div");
hello.innerText = "Hello, Declarative!";
body.appendChild(hello);
```

**for문 vs map**

```js
const arr = [1, 2, 3, 4, 5];

// #1
const result = [];

for (let i = 0; i < arr.length; i++) {
  result.push(arr[i] * 2);
}

//#2
const result = arr.map((item) => item * 2);
```

### 추상화

프로그래밍에는 `DRY(Don’t Repeat Yourself)`라는 원칙이 있습니다. 중복 코드를 만들지 말라는 뜻인데요. 코드의 중복을 줄이면 타이핑 하는 코드가 줄어든다는 직관적인 장점 뿐만 아니라, 로직의 관리 포인트가 줄어들어 유지 보수 측면에서의 장점도 있습니다.

`로직의 관리 포인트가 줄어든다`는 말은 하나의 수정사항을 반영하기 위해 여러 코드를 반복적으로 수정하지 않아도 된다는 뜻입니다. 그렇게 되면 개발자가 코드를 보다 쉽고 안전하게 수정, 추가할 수 있겠죠.

공통되는 로직을 추출하다보면 어떤 부분은 추상화 되기도 하는데요. `단일 책임 원칙` 을 따르라는 조언을 많이 듣게 됩니다. 하나의 함수가 한 가지 일을 하도록 코드를 작성하라는 건데요.

다만 엉클 밥(<클린 아키텍처> 저자 로버트 C. 마틴의 별명)은 단일 책임 원칙이 ‘함수는 하나의 일만 해야 한다’가 아니라, ‘하나의 모듈(소스코드)은 오직 하나의 액터(사용자 혹은 이해관계자)에 대해서만 책임져야 한다’로 이해해야 한다고 강조합니다.

```js
// ex)
// 적용 전 - 1) 수정하는 사용자, 2) 등록하는 사용자가 하나의 함수를 사용한다
const getInitialData = (type: 'edit' | 'register') => {
  if (type ==== 'edit') {
    // 수정 시에 필요한 초기 데이터를 불러오는 로직
  } else {
    // 등록 시에 필요한 초기 데이터를 불러오는 로직
  }
};

// 적용 후 - 1) 수정하는 사용자, 2) 등록하는 사용자가 서로 다른 함수를 사용한다
const getInitialDataForEdit = () => {
  // 수정 시에 필요한 초기 데이터를 불러오는 로직
};
const getInitialDataForRegister = () => {
  // 등록 시에 필요한 초기 데이터를 불러오는 로직
};
```

예시를 살펴보기 전에 `우발적 중복`에 대해 이야기해보겠습니다. 우발적 중복은 말 그대로 의도하지 않은 중복이기 때문에 가급적 피해야 합니다. 반면 의도한 중복은 우발적 중복에 비해 문제의 소지가 적습니다. 엉클 밥은 이 두 가지 중복을 잘 구분하여 사용해야 한다고 설명합니다.

‘하나의 모듈(소스코드)은 오직 하나의 액터(사용자 혹은 이해관계자)에 대해서만 책임져야 한다’는 정의를 다시 곱씹어 보겠습니다. 동일한 코드를 서로 다른 두 액터가 유사한 코드를 구현할 경우 억지로 합칠 필요 없다는 결론을 얻을 수 있습니다. 비록 지금은 두 코드가 유사해보일지라도 두 코드는 서로 다른 액터에 의해 다른 방향으로 발전해나갈 것이기 때문입니다.

우리의 코드가 어떤 형태의 인터페이스를 가지며 추출되어야 할지, 이 중복은 우발적인지 의도된 중복인지를 잘 생각해보며 `나눈다` 는 행위와, 어떠한 나누기, 어떠한 정도의 나누기가 좋은지에 대해서도 다시 생각해볼 수 있었으면 좋겠습니다.

### 관심사의 분리

컴퓨터 공학에서는 이렇게 '한번에 한 가지만 걱정해도 괜찮도록' 각각의 관심사에 따라 코드를 분리하는 기법을 `관심사의 분리` 라고 부릅니다.

관심사의 분리가 적절히 구현된 코드에서는 `Loose Coupling` (낮은 결합도, 각각의 코드가 서로 얽혀있지 않고 독립적으로 잘 분리되어 있음)과 `High Cohesive` (높은 응집도, 유사한 내용끼리 비슷한 위치에 잘 모여 있음)와 같은 특성을 발견할 수 있습니다.

웹 프론트엔드는 유저 시나리오 변경에 따라 인터페이스와 로직의 변경이 빈번한 편입니다. 그렇다고 하더라도 로그인 버튼의 위치를 옮길 뿐인데 로그인 로직 자체를 수정해야 한다든가 하는 식의 코드라면 곤란하겠죠?

관심사의 분리를 달성할 수 있는 대표적인 예제로서 보통 **유저 인터페이스(View)와 비즈니스(Business, Domain) 로직의 분리**를 들 수 있겠습니다.

하지만 어디까지가 비즈니스 영역이고, 어디부터가 유저 인터페이스 영역인지에 대해서는 정말 다양한 이견이 있고, 또 그것을 어떤 수준까지 분리해야 할지도 정하기 나름이기 때문에 각자의 기준을 세우는 것이 중요합니다.

- **View**

  - 사용자와 애플리케이션이 화면 상에서 상호작용 하는 영역
  - 데이터를 화면 상에 표시하는 영역
  - ex. Image, Form, Button 등
  - ex. 외부에서 주입 받은 props에만 의존하는 순수함수적 컴포넌트

- **Domain(Business) Logic**
  - 현실 세계의 `비즈니스` 규칙
    - 대출에는 대출 잔액, 이자율, 지급 일정이 필요하다 (엔티티)
    - 유저의 신용등급이 7등급 이하라면 대출이 불가하다 (유즈케이스)
  - 개발 시스템 전체 관점에서 웹은 세부사항에 가깝기 때문에 백엔드 서버 측 API에 많은 디펜던시가 있음
  - API 호출 로직을 view 로직과 분리하는 것만으로도 어느 정도 관심사의 분리를 달성할 수 있음

유사한 예시로 **Headless UI** 라는 개념이 있습니다. 디자인 시스템에서 스타일을 담당하는 부분과 로직과 상태를 담당하는 부분을 분리하는 것을 의미합니다.

[출처: 원티드 프리온보딩 프론트엔드 챌린지 8월 학습 자료](https://pollen-port-115.notion.site/8-9-20-00-88c07fc6f60d4cb3bbe3739861341a00)

## 클린 코드에 대한 참고 자료

### Clean Code의 주요원칙 (General)

- <b>Follow Standard Conventions</b> ( = Coding 표준, 아키텍쳐 표준 및 설계 가이드를 준수하라.)
- <b>Keep it Simple, Stupid</b> ( = 단순한 것이 효율적이며, 복잡함을 최소화하라.)
- <b>Boy Scout Rule</b> ( = 참고되거나 수정되는 코드는 원래보다 clean하게 해야 함.)
- <b>Root Cause Analysis</b> ( = 항상 근본적인 원인을 찾아라. 그렇지 않으면 반복될 것 이다.)
- <b>Do Not Multiple Languages in One Souce File</b> ( = 하나의 파일은 하나의 언어로 작성하라.)

### Clean Code의 주요 원칙 (Class Design)

- <b>Simple Responsibility Principle(SRP)</b> ( = 하나의 클래스는 하나의 책임만 가져야 한다.)
- <b>Open/Closed Principle (OCP)</b> ( = 클래스는 확장에 대하여 열려 있어야 하고, 변경에 대해서는 닫혀 있어야 한다.)
- <b>Liskov Substitution Principle(LSP) (</b> = 파생 클래스의 메소드는 기반 클래스의 메스드를 대체하여 사용될 수 있어야 한다.)
- <b>Interface Segregation Principle(ISP)</b> ( = 클라이언트가 사용하지 않는 메소드에 의존하지 않아야 한다.)
- <b>Dependency Inversion Principle(DIP) </b>( = 추상화된 것은 구체적인 것에 의존하면 안된다. 자주 변경되는 구체적인 것에 의존하지 말고 추상화된 것을 참조.)

[출처: Clean Code Cheat Sheet](https://www.planetgeek.ch/wp-content/uploads/2014/11/Clean-Code-V2.4.pdf)
[출처: 클린 코드란 무엇인가 ](https://www.samsungsds.com/kr/insights/cleancode-0823.html)

### Clean Code

1. <b>객체의 생성에도 유의미한 이름을 사용하라</b>.
   - 객체의 생성자가 오버로딩 되는 경우 어떠한 값으로 어떻게 생성되는지 정보가 부족할 수 있다. 그러므로 이러한 경우에는 정적 팩토리 메소드를 사용하는 것이 보다 명확한 코드를 작성하게 해 줄 것이다. 하지만 구현을 드러내는 이름은 피하는 것이 좋다.
2. <b>함수는 하나의 역할만 해야한다.</b>
   - 함수는 지정된 이름 아래에서 한 단계 수준의 추상화 수준을 유지해야 한다. 그것이 하나의 역할 및 기능만을 하는 것이다. 또는 의미 있는 다른 함수로 추출가능한 부분이 없다면 그것 역시 하나의 역할 및 기능만을 수행하고 있는 것이다.
3. <b>명령과 조회를 분리하라(Command와 Query의 분리)</b>
4. <b>오류코드 보다는 예외를 활용하자</b>
   - 오류코드를 반환하면 그에 따른 분기가 일어나게 되고, 또 분기가 필요한 경우 중첩되기 마련이다.
5. <b>여러 예외가 발생하는 경우 Wrapper 클래스로 감싸자</b>
6. <b>테스트 코드의 작성</b>

   - TDD(Test-Driven Development)는 실제 코드를 짜기 전에 단위 테스트를 먼저 작성하는 기법으로, 이를 통해 유연성, 유지보수성, 재사용성을 제공받을 수 있다. TDD의 핵심 규칙 3가지는 다음과 같다.

     - 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
     - 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
     - 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

   - 실제 코드를 변경한다는 것은 잠재적인 버그가 발생할 수 있음을 내포하고 있다. 테스트 코드가 있다면 변경된 코드를 검증함으로써 이를 해결할 수 있다. 그리고 실제 코드가 변경되면 테스트 코드 역시 변경해주어야 하는데, 이러한 이유로 테스트 코드 역시 가독성있게 작성하는 것이 필요하다.
   - 그리고 테스트 코드를 작성할 때에는 다음을 준수하는 것이 좋다.

     - 1개의 테스트 함수에 대해 assert를 최소화하라
     - 1개의 테스트 함수는 1가지 개념 만을 테스트하라

   - 또한 깨끗한 테스트 코드는 First라는 5가지 규칙을 따른다.
     - Fast: 테스트는 빠르게 동작하여 자주 돌릴 수 있어야 한다.
     - Independent: 각각의 테스트는 독립적이며 서로 의존해서는 안된다.
     - Repeatable: 어느 환경에서도 반복 가능해야 한다.
     - Self-Validating: 테스트는 성공 또는 실패로 bool 값으로 결과를 내어 자체적으로 검증되어야 한다.
     - Timely: 테스트는 적시에 즉, 테스트하려는 실제 코드를 구현하기 직전에 구현해야 한다.

7. <b>클래스의 최소화</b>
   클래스 역시 함수와 마찬가지로 간결하게 작성하는 것이 중요하다. 함수는 물리적 크기를 측정했다면 클래스는 몇개의 역할 또는 책임을 갖는지를 척도로 활용하며, 단일 책임 원칙에 따라 1가지 책임만을 가져야 한다.

8. <b>클래스의 응집도</b>
   객체 지향 관련 공부를 하면 높은 응집도와 낮은 결합도라는 얘기를 듣는다. 여기서 응집도란 클래스의 메소드와 변수가 얼마나 의존하여 사용되는지를 의미한다.

9. <b>변경하기 쉬운 클래스</b>
   요구사항은 수시로 변하기 때문에, 변경하기 쉬운 클래스를 만드는 것이 중요하다. 변경하기 쉬운 클래스는 기본적으로 단일 책임 원칙을 지켜야 한다. 또한 구현체 보다는 추상체에 의존하여야 한다. 그리고 결국 핵심은 다형성이다.

10. <b>설계 품질을 높여주는 4가지 규칙</b>

    - 모든 테스트를 실행하라: 테스트가 쉬운 코드를 작성하다 보면 SRP를 준수하고, 더 낮은 결합도를 갖는 설계를 얻을 수 있다.
    - 중복을 제거하라: 깔끔한 시스템을 만들기 위해 단 몇 줄이라도 중복을 제거해야 한다.
    - 프로그래머의 의도를 표현하라: 좋은 이름, 작은 클래스와 메소드의 크기, 표준 명칭, 단위 테스트 작성 등을 통해 이를 달성할 수 있다.
    - 클래스와 메소드의 수를 최소로 줄여라: 클래스와 메소드를 작게 유지함으로써 시스템 크기 역시 작게 유지할 수 있다.

    2~4는 리팩토링 과정에 해당한다. 2~4의 작업은 모든 테스트케이스를 작성한 후에 코드와 클래스를 정리하기 때문에 안전하다.

11. <b>디미터 법칙</b>
    디미터의 법칙은 어떤 모듈이 호출하는 객체의 속사정을 몰라야 한다는 것이다. 그렇기에 객체는 자료를 숨기고 함수를 공개해야 한다. 만약 자료를 그대로 노출하면 내부 구조가 드러나 결합도가 높아지게 된다.

[출처: 클린 코드(Clean Code) 핵심 요약 및 정리 ](https://mangkyu.tistory.com/132)
